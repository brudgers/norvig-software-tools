#+TITLE: norvig-software-tools.org
#+OPTIONS: num:nil ^:{}
* Preface
**The computer code here is not original to me.** and this document reflects several of my ongoing projects:
1. Learning 'classic' AI by working through Peter Norvig's [[http://norvig.com/paip.html][*Paradigms of Artificial Intelligence: Case Studies in Common Lisp*]].   Norvig's book is the source for the Lisp code in this project.
2. Learning more Emacs in general and org-mode in particular.
3. Developing a work process around Literate Programming.
* Introduction
These tools are from chapter 6 of Norvig's book. They expand on the work done to develop Eliza in chapter 5.
* An Interactive Interpreter
Norvig uses Eliza to introduce the read-eval-print loop. The most interesting aspect of my first impression is that the inclusion of =flatten= makes it just ever so slightly more complex than I would have imagined. 
#+BEGIN_SRC lisp
  (defun eliza ()
    "Respond to user input using pattern matching."
    (loop
       (print 'eliza>)
       (print (flatten (use-eliza-rules (read))))))
#+END_SRC
Perhaps that is the result of mixing levels of abstraction: =flatten= is used to format the output and in that sense is part of the user interface. Norvig's implementation mixes the interface with the business logic. I expected the abstractions to maintain the form =(loop (print (eval (read))))= more formally.

But enough quibbling. Norvig's big point is the power of =(read)= in Lisp. The =repl= does not require tools to perform lexical analysis and symbol lookup and parsing. There is a class of programs that have the general form:
#+BEGIN_EXAMPLE
(defun program()
  (loop
    (print <prompt>)
    (print (transform (read)))))
#+END_EXAMPLE
The flexibility of Lisp allows =transform= and =read= to be redefined easily.
** abstracting an interactive interpreter
My first impression of this was that the function should return a =lambda= similar to what might be called 'a factory': e.g. =...(lambda()(loop ...))...=. I even wrote it that way at first. Norvig's form seems likely to produce cleaner code.
#+BEGIN_EXAMPLE
  (defun interactive-interpeter (prompt transformer)
    "Reads an expression, interprets it and returns the result."
    (loop
         (print prompt)
         (print (funcall transformer (read)))))
#+END_EXAMPLE
Returning a =lambda= means the use is something like:
#+BEGIN_EXAMPLE
  (setf (symbol-function foo) 
        (interpreter-factory prompt transform))
#+END_EXAMPLE
While using Norvig's version is cleaner looking because the function definition uses =defun= and therefore looks like a function definition.
#+BEGIN_EXAMPLE
  (defun foo ()
    (interactive-interpreter prompt transform))
#+END_EXAMPLE
Norvig goes on to provide a cleaner version of =(eliza())= using =compose= that addresses my earlier gripes about mixed layers of abstraction (and I did not know this when I wrote them).
#+BEGIN_EXAMPLE
  (defun eliza()
    (interactive-interpeter 'eliza>
                            (compose #'flatten #'use-eliza-rules)))
#+END_EXAMPLE
** interactive-interpreter
#+BEGIN_SRC lisp :tangle interactive-interpreter.lisp :noweb tangle
  ;;; This file autogenerated from eliza-cl.org

  <<prompt-generator>>

  (defun interactive-interpeter (prompt transformer)
    "Reads an expression, interprets it and returns the result."
    (loop
       (handler-case
           (progn
             (if (stringp prompt)
                 (print prompt)
                 (funcall prompt))
             (print (funcall transformer (read))))
         ;; in case of error do this
         (error (condition)
           (format t "~&:: Error ~a ignored, back to top level."
                   condition)))))
#+END_SRC
** prompt-generator
Once again impressed with Norvig's book. It's not enough to show a more robust interpreter. He provides =prompt-generator= to provide insight and show the mortality of a wizard behind the curtain. It's the mixture of expressiveness at high and low levels that makes Common Lisp intriguing. 
#+NAME: prompt-generator
#+BEGIN_SRC lisp
  (defun prompt-generator (&optional (num 0) (ctl-string "[~d] "))
    "Return a function that prints prompts like [1], [2], etc."
    #'lambda () (format t clt-string (incf num)))
#+END_SRC
 
* A Pattern Matching Tool
